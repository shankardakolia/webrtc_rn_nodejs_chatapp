1. Introduction
1.1 Product Overview
This PRD outlines the requirements for developing a real-time video chat application. The app will enable users to engage in peer-to-peer video and audio calls, with optional text messaging via WebRTC data channels. The frontend will be built using React Native with Expo for cross-platform mobile development (iOS and Android). The backend will be a Node.js server handling signaling for WebRTC connections, user authentication, and session management.
WebRTC will be used for direct peer-to-peer communication to minimize latency and server load, while the Node.js backend acts as a signaling server to facilitate connection establishment (e.g., exchanging ICE candidates and SDP offers/answers).
1.2 Objectives

Provide a seamless, low-latency video chat experience.
Ensure cross-platform compatibility via React Native Expo.
Support local development and testing of the backend before deployment.
Enable easy deployment of the backend to Vercel for production.
Focus on core functionality for an MVP (Minimum Viable Product), with scalability in mind.

1.3 Assumptions and Constraints

The app targets mobile devices primarily; web support is out of scope.
WebRTC compatibility: Assumes devices support WebRTC (most modern iOS/Android do).
No advanced features like group calls or recording in MVP.
Backend deployment to Vercel: Assumes Vercel's serverless functions and WebSocket support (via durable objects or similar if needed).
Data privacy: Basic compliance with end-to-end encryption via WebRTC; no server-side media storage.
Development environment: Node.js v18+, Expo CLI, and compatible libraries.

2. Target Audience and Use Cases
2.1 Target Audience

Individuals seeking quick video chats (e.g., friends, family, or remote teams).
Developers testing WebRTC integrations.
Users on iOS and Android devices.

2.2 Key Use Cases

User signs up/logs in and initiates a video call with another user.
Users exchange text messages during a call.
Handle call acceptance/rejection and disconnection.
Fallback to audio-only if video permissions are denied.
Local testing: Developer runs backend on localhost to simulate signaling.

3. Functional Requirements
3.1 User Authentication

Users can register with email/password or OAuth (e.g., Google).
Login/logout functionality.
JWT-based authentication for secure API calls.
Backend handles user database (using MongoDB or SQLite for local testing).

3.2 Real-Time Communication

Video/Audio Calls: Initiate, accept, and end peer-to-peer calls using WebRTC.
Display local/remote video streams.
Toggle microphone/camera on/off.
Handle screen orientation changes.

Text Chat: In-call text messaging via WebRTC Data Channels.
Signaling: Backend facilitates connection setup via WebSockets (e.g., using Socket.io).
Exchange SDP offers/answers and ICE candidates.


3.3 User Interface (Frontend)

Screens:
Login/Register screen.
User list/search screen (to find and call other users).
Call screen: Video previews, controls (mute, end call), and chat input.

Notifications: Push notifications for incoming calls (using Expo Notifications).
Error Handling: Graceful handling of network issues, permission denials.

3.4 Backend Services

API Endpoints:
/auth/register, /auth/login (POST).
/users/search (GET) â€“ Search for users by username/email.
WebSocket events: join, offer, answer, ice-candidate, call-ended.

Database: Store user data (usernames, emails, hashed passwords). Use Mongoose for MongoDB integration.
Signaling Logic: Maintain active user sessions and route signals between peers.

4. Non-Functional Requirements
4.1 Performance

Latency: Aim for <200ms for signaling; WebRTC handles media latency.
Scalability: Backend should handle up to 100 concurrent connections in MVP (Vercel serverless scales automatically).
Offline Handling: App detects network loss and attempts reconnection.

4.2 Security

HTTPS for all communications.
End-to-end encryption for media (native to WebRTC).
Validate user inputs to prevent injection attacks.
Rate limiting on API endpoints.

4.3 Reliability

Backend uptime: 99% (leveraging Vercel's infrastructure).
Graceful degradation: Fall back to audio if video fails.

4.4 Usability

Intuitive UI with React Native components (e.g., using Expo AV for media).
Accessibility: Support for screen readers and high-contrast modes.

4.5 Compatibility

React Native: v0.75+ with Expo SDK 51+.
WebRTC: Use react-native-webrtc library.
Node.js: v20+ for backend.
Browsers/Devices: iOS 14+, Android 8+.

5. Technical Architecture
5.1 Frontend (React Native Expo)

Stack: React Native, Expo, react-native-webrtc, @expo/vector-icons, expo-av, expo-notifications.
State Management: Redux or Context API for managing call states.
Navigation: React Navigation for screens.
WebRTC Integration:
Use RTCPeerConnection for connections.
MediaStream for camera/microphone access.
Data channels for text.


5.2 Backend (Node.js)

Stack: Express.js for API, Socket.io for WebSockets, Mongoose for DB.
Signaling Server: Socket.io handles real-time events.
Database: Local MongoDB for testing; MongoDB Atlas for production.
Environment: Use .env for configs (e.g., DB URI, JWT secret).

5.3 Overall Architecture

WebRTC Flow:
User A initiates call to User B via signaling server.
Server notifies User B (WebSocket push).
Users exchange SDP/ICE via server.
Direct P2P connection established for media.

Deployment:
Local: Run backend with node server.js or nodemon.
Production: Deploy to Vercel (use vercel.json for routes, support for serverless functions and WebSockets).


6. Development Plan
6.1 Phases

Setup (1-2 days):
Initialize React Native Expo project: npx create-expo-app chat-app.
Set up Node.js backend: npm init, install dependencies (express, socket.io, mongoose, bcrypt, jwt).
Integrate react-native-webrtc in frontend.

Backend Development (3-5 days):
Implement auth APIs and user model.
Set up Socket.io for signaling.
Test locally: Run on localhost:3000, use tools like Postman for APIs and browser for WebSocket testing.

Frontend Development (5-7 days):
Build auth screens.
Implement call initiation and WebRTC logic.
Integrate with backend APIs/WebSockets.

Integration and Testing (3-5 days):
Connect frontend to local backend.
Test end-to-end: Simulate calls between two emulators/devices.

Deployment (1-2 days):
Deploy backend to Vercel: Push to GitHub, link to Vercel, configure environment variables.
Update frontend to point to Vercel URL.
Publish Expo app (eas build for iOS/Android).


6.2 Tools and Dependencies

Frontend: Expo CLI, Yarn/NPM, VS Code.
Backend: Nodemon for hot reloading, MongoDB Compass for local DB.
Testing: Jest for unit tests, Expo Go for mobile preview.

7. Testing Strategy
7.1 Local Testing

Backend: Unit tests for APIs (using Jest/Supertest). Manual WebSocket testing with clients like wscat.
Frontend: Simulator testing with Expo Go. Test on physical devices for camera/mic.
End-to-End: Run two app instances, one calling the other via local backend.

7.2 Integration Testing

Verify signaling flow: SDP exchange, ICE gathering.
Test edge cases: Network disconnect, permission denials.

7.3 Production Testing

After Vercel deployment, test with remote URLs.
Monitor logs via Vercel dashboard.

8. Risks and Mitigations

WebRTC Compatibility: Test on multiple devices; provide fallbacks.
Vercel WebSocket Limits: If issues, consider alternatives like Heroku for MVP.
Permissions: Guide users on granting camera/mic access.
Scalability: Monitor usage; optimize for more users if needed.

9. Next Steps

Review and approve this PRD.
Begin development with backend setup for local testing.
Schedule check-ins for progress.